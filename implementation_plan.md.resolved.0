# Proxy Verification Plan

## Goal
Verify that the `tcp-mqtt-proxy.py` correctly handles bidirectional traffic between the Meshtastic TCP node and the MQTT broker. specifically focusing on:
1.  **RX (Node -> MQTT)**: Incoming radio packets (e.g., !ping responses) are correctly wrapped in a `ServiceEnvelope`, assigned the correct channel (decoding "LongFast" from index 0), and published to MQTT.
2.  **TX (MQTT -> Node)**: Messages from MQTT are forwarded to the node.

## User Review Required
> [!IMPORTANT]
> The verification involves running the proxy on the live device (`192.168.50.50`). I will need to stop any existing instance (Docker or systemd) to run the test instance.

## Proposed Steps

### 1. Preparation
- Stop existing Docker container: `docker compose down` (on remote).
- Ensure configuration is correct (Environment variables in `docker-compose.yml`).

### 2. Live Execution & Monitoring
Instead of running a separate test script, we will run the proxy interactively to see real-time logs.
- Run: `python3 tcp-mqtt-proxy.py` (on remote, if dependencies are installed locally) or `docker compose up` (foreground).
- **Recommendation**: Use `docker compose up --build` to ensure the latest code is running and watch stdout.

### 3. Verification Scenarios
#### A. Map/NodeInfo Update
- **Action**: Restart the TCP node or wait for a periodic update.
- **Expected Log**: `Publishing to MQTT: Topic=msh/...` with `chan_name="LongFast"` (or specific channel) and `should_retain=True` for PortNum=4 (NodeInfo).

#### B. Text Message / Ping
- **Action**: Send a message from a client (MeshMonitor) or another node.
- **Expected Log**: `Publishing to MQTT` with correct channel name.
- **Verify**: The message appears in the MQTT broker (can verify via `mosquitto_sub` if available, or just trust logs).

## Pre-requisites
- SSH Access (Verified).
- `docker` and `docker compose` on the remote (Verified).
