# Multi-Interface MQTT Proxy - Implementation Plan

## Goal

Extend the MQTT proxy to support TCP, Serial, and BLE interfaces, allowing it to work with any Meshtastic node connection type.

## Proposed Architecture

### 1. Interface Classes

Create three interface wrapper classes that all implement the same [_handleFromRadio()](file:///C:/Users/dremb/.gemini/antigravity/brain/cd00e979-2d9a-4abd-80d8-38d6d36e6d90/tcp-mqtt-proxy.py#340-376) override:

```python
class RawTCPInterface(TCPInterface):
    def _handleFromRadio(self, fromRadio):
        # Intercept mqttClientProxyMessage
        # Publish to MQTT
        
class RawSerialInterface(SerialInterface):
    def _handleFromRadio(self, fromRadio):
        # Same logic as TCP
        
class RawBLEInterface(BLEInterface):
    def _handleFromRadio(self, fromRadio):
        # Same logic as TCP
```

### 2. Interface Selection

Add environment variable for interface type:

```yaml
environment:
  - INTERFACE_TYPE=${INTERFACE_TYPE:-tcp}  # tcp, serial, or ble
  - SERIAL_PORT=${SERIAL_PORT:-/dev/ttyUSB0}
  - BLE_ADDRESS=${BLE_ADDRESS:-}
  - TCP_NODE_HOST=${TCP_NODE_HOST:-localhost}
  - TCP_NODE_PORT=${TCP_NODE_PORT:-4403}
```

### 3. Factory Function

Create interface factory similar to Meshtastic CLI:

```python
def create_interface(interface_type):
    if interface_type == "tcp":
        return RawTCPInterface(TCP_NODE_HOST, portNumber=TCP_NODE_PORT, timeout=TCP_TIMEOUT)
    elif interface_type == "serial":
        return RawSerialInterface(SERIAL_PORT)
    elif interface_type == "ble":
        return RawBLEInterface(BLE_ADDRESS)
    else:
        raise ValueError(f"Unknown interface type: {interface_type}")
```

## Implementation Steps

### Phase 1: Refactor Current Code
- [x] Extract common [_handleFromRadio()](file:///C:/Users/dremb/.gemini/antigravity/brain/cd00e979-2d9a-4abd-80d8-38d6d36e6d90/tcp-mqtt-proxy.py#340-376) logic into shared function
- [ ] Move TCP-specific code into [RawTCPInterface](file:///C:/Users/dremb/.gemini/antigravity/brain/cd00e979-2d9a-4abd-80d8-38d6d36e6d90/tcp-mqtt-proxy.py#335-376) class
- [ ] Test TCP interface still works

### Phase 2: Add Serial Support
- [ ] Create `RawSerialInterface` class
- [ ] Add `SERIAL_PORT` environment variable
- [ ] Test with USB-connected node
- [ ] Update documentation

### Phase 3: Add BLE Support
- [ ] Create `RawBLEInterface` class  
- [ ] Add `BLE_ADDRESS` environment variable
- [ ] Test with BLE-connected node
- [ ] Update documentation

### Phase 4: Interface Selection
- [ ] Create `create_interface()` factory function
- [ ] Add `INTERFACE_TYPE` environment variable
- [ ] Update main loop to use factory
- [ ] Test all three interface types

### Phase 5: Documentation
- [ ] Update README with interface options
- [ ] Update CONFIG.md with new variables
- [ ] Add examples for each interface type

## Configuration Examples

### TCP (Current)
```yaml
INTERFACE_TYPE=tcp
TCP_NODE_HOST=192.168.1.100
TCP_NODE_PORT=4403
```

### Serial
```yaml
INTERFACE_TYPE=serial
SERIAL_PORT=/dev/ttyUSB0
```

### BLE
```yaml
INTERFACE_TYPE=ble
BLE_ADDRESS=AA:BB:CC:DD:EE:FF
```

## Benefits

✅ **Universal Proxy** - Works with any Meshtastic connection type
✅ **Consistent Behavior** - Same MQTT proxy logic for all interfaces
✅ **Easy Configuration** - Single environment variable to switch types
✅ **Docker Compatible** - Serial via device mapping, BLE via host network

## Challenges

⚠️ **BLE in Docker** - May require `--privileged` and host network mode
⚠️ **Serial Permissions** - Need proper device permissions in container
⚠️ **Platform Dependencies** - BLE support varies by OS

## Next Steps

1. Get user approval for this plan
2. Start with Phase 1 (refactoring)
3. Implement Serial support first (easier than BLE)
4. Add BLE support last (most complex)
